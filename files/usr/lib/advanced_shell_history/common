#!/bin/bash
#
# Author: cpa@google.com (Carl Anderson)
#


# Put the history.db in HOME or use /dev/shm if no HOME exists.
if [[ -d "${HOME}" ]]; then
  export AH_HISTORY_DB="${HOME}/.history.db"
else
  export AH_HISTORY_DB=/dev/shm/.history_${UID}.db
fi
readonly AH_HISTORY_DB


# Ensure there is a HISTFILE.
if [[ -z "${HISTFILE}" ]]; then
  export HISTFILE="${AH_HISTORY_DB%.db}"
  ash_log -a "WARN: HISTFILE undefined. Exporting HISTFILE as: '${HISTFILE}'."
fi
if [[ ! -e "${HISTFILE}" ]] && ! touch "${HISTFILE}" &>/dev/null; then
  ash_log -a "Failed to create shell history file: '${HISTFILE}'."
fi
if ! chmod u+rw "${HISTFILE}" &>/dev/null; then
  ash_log -a "Failed to make shell history file readable and writeable."
fi


##
# This is invoked when a user session is exited.
#
# Args:
#   rval: The numeric exit code from the last user-entered command.
#
function ah::end_session() {
echo "Ending session ${AH_SESSION_ID} with args: ${@}"
  ah::log "${@}"
  ash_log --end-session --exit-code ${1}
}

# This is executed when the user types 'exit'
trap 'ah::end_session ${?} ${PIPESTATUS[@]} ${pipestatus[@]}' EXIT TERM

# This avoids logging duplicate commands when the user presses Ctrl-C while
# entering a command.
trap 'ASH_SKIP=/bin/true' INT
export ASH_SKIP=/bin/false


##
# This is invoked immediately before each new prompt is displayed for the user.
#
# Args:
#   rval: The numeric exit code from the last user-entered command.
#   pipes: The set of pipe exit codes (one or more codes).
#
function ah::log() {
  if ${ASH_SKIP}; then
    ASH_SKIP=/bin/false
    return
  fi

  local no start end cmd rval="${1}" && shift
  read -r no start end cmd <<< "$( ah::last_command )"
  ash_log -e ${rval} -s ${start} -f ${end} -n ${no} -p "${@}" -c "${cmd}"
}


# Protect the functions.
readonly -f ah::end_session
readonly -f ah::log

export -f ah::end_session
export -f ah::log
