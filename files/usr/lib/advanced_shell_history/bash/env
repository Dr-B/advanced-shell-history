#!/bin/bash
#
# Author: cpa@google.com (Carl Anderson)
#

source "/usr/lib/advanced_shell_history/common" || exit 1


# Display error and abort if PROMPT_COMMAND is readonly.
if readonly -p | grep -q "^declare -[[:alpha:]]\+ PROMPT_COMMAND="; then
  if [[ "${PROMPT_COMMAND//ah::/}" == "${PROMPT_COMMAND}" ]]; then
    ash_log -a "Make PROMPT_COMMAND writable to save advanced command history."
    return
  fi
fi
export PROMPT_COMMAND="ah::begin_session"

# HISTCONTROL is emptied primarily to remove the options that de-dupe identical
# successive commands and remove comands with leading spaces from history.
export HISTCONTROL=""
readonly HISTCONTROL

# HISTTIMEFORMAT is changed to unix epoch time to allow easy duration
# calculations by subtracting start from end timestamps.
export HISTTIMEFORMAT="%s "
readonly HISTTIMEFORMAT


##
# This is invoked when a new user session begins.
#
function ah::begin_session() {
  export PROMPT_COMMAND="ah::precmd \${?} \${PIPESTATUS[@]}"
  export ASH_SESSION_ID="$( ash_log --get-session-id )"
  ash_log -a "Advanced History is enabled (session: ${ASH_SESSION_ID})."
  readonly ASH_SESSION_ID PROMPT_COMMAND
}


##
# Log the previous command and execute the previous PROMPT_COMMAND (if any)
# afterward.  The previous command exit code is reset after this function.
#
function ah::precmd() {
  ah::log ${@}
  if typeset -p ASH_PROMPT_COMMAND &>/dev/null; then
    "${ASH_PROMPT_COMMAND}"
  fi
  # Causes the exit code to be reset to what it was before logging.
  local rval=${1} && shift
  ASH_PIPESTATUS=( ${@} )
  ash_exit ${rval}
}


##
# Invoked by ah::log.
#
function ah::last_command() {
  local cmd_no start_ts end_ts="$( date +%s )" cmd
  read -r cmd_no start_ts cmd <<< "$( builtin history 1 )"
  echo ${cmd_no} ${start_ts} ${end_ts} "${cmd}"
}


# Protect the functions.
readonly -f ah::begin_session
readonly -f ah::last_command
readonly -f ah::precmd

# Export functions used by subshells (not begin_session).
export -f ah::last_command
export -f ah::precmd
